<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="referrer" content="origin">
  <title>My portfolio</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">

  <!-- Favicons -->
  <link href="img/favicon.png" rel="icon">
  <link href="img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Bootstrap CSS File -->
  <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Libraries CSS Files -->
  <link href="lib/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="lib/animate/animate.min.css" rel="stylesheet">
  <link href="lib/ionicons/css/ionicons.min.css" rel="stylesheet">
  <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">
  <link href="lib/lightbox/css/lightbox.min.css" rel="stylesheet">

  <!-- Main Stylesheet File -->
  <link href="css/style.css" rel="stylesheet">
  <style type="text/css">
    #editor,#editor1,#editor2,#editor3 {
    height: 100%;
    width:50%;
    display:inline-block;
    }
    p{
      font-weight: bold;
    }
  </style>
</head>

<body id="page-top" onload="ready()">

  <!--/ Nav Star /-->
  <nav class="navbar navbar-b navbar-trans navbar-expand-md fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll" href="#page-top">My Portfolio</a>
      <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarDefault"
        aria-controls="navbarDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
      </button>
      <div class="navbar-collapse collapse justify-content-end" id="navbarDefault">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link js-scroll active" href="#home">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#about">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#service">Services</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#work">Projects</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll" href="#contacts">Contact</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <!--/ Nav End /-->

  <!--/ Intro Skew Star /-->
  <section id="home" class="intro route bg-image" style="background-image: url(img/intro1-bg.jpg)">
    <div class="overlay-itro"></div>
    <div class="intro-content display-table">
      <div class="table-cell">
        <div class="container">
          <!--<p class="display-6 color-d">Hello, world!</p>-->
          <h1 class="intro-title mb-4">I am Adewale Adeleye</h1>
          <p class="intro-subtitle"><span class="text-slider-items">C++ Programmer,Web Developer,Backend Developer,Data Structures and Algorithms Enthusiast</span><strong class="text-slider"></strong></p>
          <!-- <p class="pt-3"><a class="btn btn-primary btn js-scroll px-4" href="#about" role="button">Learn More</a></p> -->
        </div>
        <button class="btn-primary" style="border-radius: 20px; z-index: 1; padding: 5px; margin-top: 20px; "><a href="my-resume_2.pdf" download="my-resume_2.pdf"><h4 style="color: white;">view resume</h4></a></button>
      </div>
    </div>
  </section>
  <!--/ Intro Skew End /-->

  <section id="about" class="about-mf sect-pt4 route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="box-shadow-full">
            <div class="row">
              <div class="col-md-6">
                <div class="row">
                  <div class="col-sm-6 col-md-5">
                    <div class="about-img">
                      <img src="img/foto1.jpg" class="img-fluid rounded b-shadow-a" alt="">
                    </div>
                  </div>
                  <div class="col-sm-6 col-md-7">
                    <div class="about-info">
                      <p><span class="title-s">Name: </span> <span>Adewale Adeleye</span></p>
                      <p><span class="title-s">Profile: </span> <span>Software developer</span></p>
                      <p><span class="title-s">Email: </span> <span>adeleyea5@gmail.com</span></p>
                      <p><span class="title-s">Phone: </span> <span>(234) 7083429144</span></p>
                    </div>
                  </div>
                </div>
                <div class="skill-mf">
                  <p class="title-s">Skill</p>
                  <span>Critical Thinking</span> <span class="pull-right">85%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 85%" aria-valuenow="85" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>Communication</span> <span class="pull-right">85%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 85%" aria-valuenow="85" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>PHP</span> <span class="pull-right">80%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 80%" aria-valuenow="80" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>C++</span> <span class="pull-right">75%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 75%;" aria-valuenow="75" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>MySQL</span> <span class="pull-right">75%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 75%" aria-valuenow="75" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>Javascript</span> <span class="pull-right">65%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 65%" aria-valuenow="65" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>
                  <span>Matlab</span> <span class="pull-right">65%</span>
                  <div class="progress">
                    <div class="progress-bar" role="progressbar" style="width: 65%" aria-valuenow="65" aria-valuemin="0"
                      aria-valuemax="100"></div>
                  </div>

                </div>
              </div>
              <div class="col-md-6">
                <div class="about-me pt-4 pt-md-0">
                  <div class="title-box-2">
                    <h5 class="title-left">
                      About me
                    </h5>
                  </div>
                  <p class="lead" style="font-weight: normal;">
                    I am a recent graduate of Electronic and Electrical
                    engineering with productive work experience in writing
                    software, setting up and managing IT Infrastructures. A
                    detail-oriented and hardworking personnel with
                    remarkable, analytical and logical skills, expert in
                    performing complex operations. Able to maintain
                    quality/standards and leverage technology to provide
                    solutions to customers/staffs. Result driven, Innovative
                    and Willing to Learn.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!--/ Section Services Star /-->
  <section id="service" class="services-mf route">
    <div class="section-counter paralax-mf bg-image" style="background-image: url(img/counters-bg.jpg)">
    <div class="overlay-mf"></div>
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a" style="color: white">
              Services
            </h3>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-md-4">
          <div class="service-box">
            <div class="service-ico">
              <span class="ico-circle"><i class="ion-monitor"></i></span>
            </div>
            <div class="service-content">
              <h2 class="s-title">C++ programming</h2>
              <p class="s-description text-center">
                I write C and C++ projects on real time systems, networking, coding competitions,etc. 
              </p>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="service-box">
            <div class="service-ico">
              <span class="ico-circle"><i class="ion-code-working"></i></span>
            </div>
            <div class="service-content">
              <h2 class="s-title">Web Development</h2>
              <p class="s-description text-center">
                I develop websites and web applications ranging from simple projects to complex projects under the right standards.
              </p>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="service-box">
            <div class="service-ico">
              <span class="ico-circle"><i class="ion-monitor"></i></span>
            </div>
            <div class="service-content">
              <h2 class="s-title">Matlab</h2>
              <p class="s-description text-center">
                 I write matlab for projects on real time systems,i run simulations with matlab and simulink 
              </p>
            </div>
          </div>
        </div>
      </div>
      </div>
    </div>
  </section>

  <!--/ Section Portfolio Star /-->
  <section id="work" class="portfolio-mf sect-pt4 route">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="title-box text-center">
            <h3 class="title-a">
              Projects
            </h3>
            <div class="line-mf"></div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-1.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">CSlab Documentation</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><a style="color:blue" href="https://cslab-doc.000webhostapp.com/new_login.php">Go to web page</a></span> <!-- / <span class="w-date">18 Sep. 2018</span> -->
                    </div>
                  </div>
                  <<!-- div class="col-sm-4">
                    <div class="w-like">
                      <span class="ion-ios-plus-outline"></span>
                    </div>
                  </div> -->
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-2.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">Smartirrigation web Api</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><a style="color:blue" href="http://www.smartirrigate.org">Go to web page</a></span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
         <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-3.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">Ife tourism</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><a style="color:blue" href="http://ifetourism.atspace.cc/"> Go to web page</a></span> <!-- / <span class="w-date">18 Sep. 2018</span> -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-4.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">Promotion tracking site(still under construction)</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><a style="color:blue" href="https://www.github.com/Adelee2/promotion_tracker"> github link for the code</a></span> <!-- / <span class="w-date">18 Sep. 2018</span> -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-5.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">Modified Leach network</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><button type="button" class="btn btn-primary" data-toggle="modal" data-target="#exampleModalCenter">View Code</button>
                      </span> <!-- / <span class="w-date">18 Sep. 2018</span> -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="work-box">
            <div data-lightbox="gallery-mf">
              <div class="work-img">
                <img src="img/work-6.jpg" alt="" class="img-fluid">
              </div>
              <div class="work-content">
                <div class="row">
                  <div class="col-sm-8">
                    <h2 class="w-title">Few Other projects on c++</h2>
                    <div class="w-more">
                      <span class="w-ctegory"><button type="button" class="btn btn-primary" data-toggle="modal" data-target=".bd-example-modal-lg">View more</button></span> <!-- / <span class="w-date">18 Sep. 2018</span> -->
                      <div class="modal fade bd-example-modal-lg" id="exampleModalScrollable" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
                      <div class="modal-dialog modal-lg" role="document">
                        <div class="modal-content">
                          <div class="modal-header">
                            <h5 class="modal-title" id="exampleModalScrollableTitle">challanges attempted on data structures and algorithms</h5>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                              <span aria-hidden="true">&times;</span>
                            </button>
                          </div>
                          <div class="modal-body">
                            <div class="container-fluid">
                              <div class="row" style="height: 50vh;">
                                <div class="col-md-4" style="display: inline-block;">
                                  <h5>IEEE snake and ladder quiz</h5>
                                  <p>
                                    Snakes and ladders is a well known board game that goes back many centuries. Rules are simple, players start at the bottom left, roll the dice to move in a zig-zag path towards the top-left corner, use ladders to get higher, eaten by snakes to get back to their tail. Your task is to simulate the board game among players at a given board
                                </p>
                              </div>
                                <div class="col-md-8 ml-auto" id="editor">
                                  
                                </div>
                              </div>
                              <div style="height: 10px;"></div>
                              <div class="row" style="height: 50vh;">
                                <div class="col-md-4 ml-auto"style="display: inline-block;">
                                  <h5>Eightqueens</h5>
                                  <p>Time: 5h
                                    Difficulty: quite hard
                                    +===============+<br>
                                    Given a chess board and eight queens that move according to the chess rules, find every possible way to place the queens in order for them NOT to touch eachother
                                    <br>
                                    +================+
                                  </p>
                                </div>
                                <div class="col-md-8 ml-auto" id="editor1">
                                
                                </div>
                              </div>
                               <div style="height: 10px;"></div>
                              <div class="row" style="height: 50vh;">
                                <div class="col-md-4 ml-auto"style="display: inline-block;">
                                    <h5>Graph Breadth first search</h5>
                                    <p>
                                     Find number of shaded boxes between any coordinate A to S using an optimized method
                                  </p>
                                </div>
                                <div class="col-md-8 ml-auto" id="editor2">
                                  
                                </div>
                              </div>
                            </div>
                          </div>
                          <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Modal -->
<div class="modal fade" id="exampleModalCenter" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalCenterTitle">Modified Leach network</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <div class="container-fluid">
          <div class="row" >
            <div class="col-md-12" style="display: inline-block;"><p></p></div>
            <div class="col-md-12 ml-auto" id="editor3" style="height: 70vh;">
              
            </div>
          </div>
      </div>
      <!-- <div style="height:25px;"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div> -->
    </div>
  </div>
</div>
  </section>
  <!--/ Section Portfolio End /-->

  <!--/ Section Contact-Footer Star /-->
  <section id="contacts" class="paralax-mf footer-paralax bg-image sect-mt4 route" style="background-image: url(img/overlay-bg.jpg)">
    <div class="overlay-mf"></div>
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <div class="contact-mf">
            <div id="contact" class="box-shadow-full">
              <div class="row">
                <div class="col-md-6">
                  <div class="title-box-2">
                    <h5 class="title-left">
                      Send Message
                    </h5>
                  </div>
                  <div>
                    <form action="http://formspree.io/adeleyea5@gmail.com" method="post" role="form">
                      <div id="sendmessage">Your message has been sent. Thank you!</div>
                      <div id="errormessage"></div>
                      <div class="row">
                        <div class="col-md-12 mb-3">
                          <div class="form-group">
                            <input type="text" name="name" class="form-control" id="name" placeholder="Your Name" data-rule="minlen:4" data-msg="Please enter at least 4 chars" />
                            <div class="validation"></div>
                          </div>
                        </div>
                        <div class="col-md-12 mb-3">
                          <div class="form-group">
                            <input type="email" class="form-control" name="_replyto" id="email" placeholder="Your Email" data-rule="email" data-msg="Please enter a valid email" />
                            <div class="validation"></div>
                          </div>
                        </div>
                        <div class="col-md-12 mb-3">
                            <div class="form-group">
                              <input type="text" class="form-control" name="subject" id="subject" placeholder="Subject" data-rule="minlen:4" data-msg="Please enter at least 8 chars of subject" />
                              <div class="validation"></div>
                            </div>
                        </div>
                        <div class="col-md-12 mb-3">
                          <div class="form-group">
                            <textarea class="form-control" name="body" rows="5" data-rule="required" data-msg="Please write something for us" placeholder="Message"></textarea>
                            <div class="validation"></div>
                          </div>
                        </div>
                        <div class="col-md-12">
                          <button type="submit" class="button button-a button-big button-rouded">Send Message</button>
                        </div>
                      </div>
                    </form>
                  </div>
                </div>
                <div class="col-md-6">
                  <div class="title-box-2 pt-4 pt-md-0">
                    <h5 class="title-left">
                      Get in Touch with me
                    </h5>
                  </div>
                  <div class="more-info">
                    <ul class="list-ico">
                      <li><span class="ion-ios-location"></span> Osun State, Nigeria </li>
                      <li><span class="ion-ios-telephone"></span> (234) 7083429144</li>
                      <li><span class="ion-email"></span> adeleyea5@gmail.com</li>
                    </ul>
                  </div>
                  <div class="socials">
                    <ul>
                      <li><a href=""><span class="ico-circle"><i class="ion-social-facebook"></i></span></a></li>
                      <li><a href=""><span class="ico-circle"><i class="ion-social-instagram"></i></span></a></li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <footer>
      <div class="container">
        <div class="row">
          <div class="col-sm-12">
            <div class="copyright-box">
              <p class="copyright">&copy; Copyright <strong>Adelee2 Portfolio</strong>. All Rights Reserved</p>
            </div>
          </div>
        </div>
      </div>
    </footer>
  </section>
  <!--/ Section Contact-footer End /-->

  <a href="#" class="back-to-top"><i class="fa fa-chevron-up"></i></a>
  <div id="preloader"></div>
  <script type="text/javascript">
    function setupEditor()
    {
      window.editor = ace.edit("editor");
      editor.setTheme("ace/theme/monokai");
      editor.getSession().setMode("ace/mode/c_cpp");
      editor.setValue(`
        #include "snake_ladder.h"

        void Get_coord::snake_coordinate()
        {
          string temp;
          int k=0;
          cout<<"\n";
          getline(cin,temp);
          //converting string to array
          
          for(size_t i=0;i<temp.size();i++){
            if(temp[i]!=' '){
               int arr = temp[i] -'0';
               arr_cord.push_back(arr);
             }
            }
            
        }

        void Get_coord::ladder_coordinate()
        {
          string temp;int k=0;
          cout<<"\n";
          getline(cin,temp);
          //converting string to array
          for(size_t i=0;i<temp.size();i++){
            if(temp[i]!=' '){
               int arr = temp[i] -'0';
               arr_cord1.push_back(arr);
             }
            }
        }


        void Snake_ladder::draw(int size)
        {
          dimension=size;
          int k=(dimension * dimension);
          int temp1,temp2;
          for(size_t i=0;i<dimension;i++){
            board.push_back(vector<int>());
            if(i%2==0){
              for(size_t j=0;j<dimension;j++){
                temp1=k-j;
                board[i].push_back(temp1);
              }
              k=temp1-dimension;
            }
            else{
              for(size_t j=0;j<dimension;j++){
        //      cout<<j<<" ";
              temp2=k++;
                board[i].push_back(temp2);
        //        cout<<board[i][j]<<" ";
              }
              k=temp2-dimension;
            }
          }

        }

        void Snake_ladder::display()
        {
        //  draw();
          for(auto i : board){
            for(auto j : i){
              cout<<setw(5)<<j<<setw(5);
            }
            cout<<"\n";
          }
        }

        int Snake_ladder::roll_dice(int p)
        {
        //  Get_result myresult[players]; 
             //keeps record of the result of each player
          int die1,die2,die_t,result=0;
          cout<<"\nEnter 1st die ";
          cin>>die1;
          cout<<"\nEnter 2nd die ";
          cin>>die2;
          

          die_t = die1 + die2;
          
          auto len=arr_cord.size();
          auto len1=arr_cord1.size();
          
          cout<<"len "<<len<<"\n";
          cout<<"len1 "<<len1<<"\n";
          for(size_t i=0;i<dimension;i++){
            if(myresult[p].results>(dimension * dimension)){
              cout<<"its out ";
              break;
            }
            else{
            for(size_t j=0;j<dimension;j++){
              
              if(board[i][j]==die_t){
        //        cout<<die_t;
                cout<<" ("<<i<<","<<j<<"), ";
                for(size_t k=0;k<len;k+=4){
        //          cout<<"test_yes!!!!!!!";
                  if(i==arr_cord[k] && j==arr_cord[k+1]){  //if die1 + die2 falls on the head of the snake,go back to its tail result = value of its tail
                  cout<<" snake head ";
                    result=board[arr_cord[k+2]][arr_cord[k+3]];
                  }
                  else{
                    cout<<" no snake ";
                    result+=board[i][j];
                  }
                }
                for(size_t m=0;m<len1;m+=4){
                  if(i==arr_cord1[m] && j==arr_cord1[m+1]){ //if die1 + die2 falls on ladder,it jumps it up the ladder;result=value of the top ladder
                    result+= board[arr_cord1[m+2]][arr_cord1[m+3]];
                    cout<<" ladder seen ";
                  }
                }
              }
            }
          }
          }
          myresult[p].results=result;
          cout<<"result "<<p<<" "<<myresult[p].results<<" \n";
        //  result=0;
        //  return result;
        }
        void Snake_ladder::display_test(){
          cout<<"entered\n";
          for(size_t i=0;i<dimension;i++){
            for(size_t j=0;j<dimension;j++){
              cout<<board[i][j]<<" ";
            }
            cout<<"\n"; 
          }
        }
        bool Snake_ladder::winner(int i)
        {
        //  Get_result myre
            return (myresult[i].results> (dimension * dimension))? true: false;
        }

        int main()
        {
          int input,i=0,counter=0;

          cout<<"Enter the size of board you want: ";
          cin>>input;
          if(input %2 ==0){
             int count=0,count1=0;    
            cout<<"Enter number of players: ";
            cin>>players;
            if(players<=10 && players >1) {
              Get_coord mysnake_ladders;
              int snakes;
                 cout<<"Enter number of snakes: ";
                 cin>>snakes;               //gets total number of snakes
                 cout<<"\n";
                 cout<<"Enter coordinate of the snake";
                 snakes+=1;
                 while(snakes>0){
                  mysnake_ladders.snake_coordinate(); //gets coordinates of each snake(its head and tail) and process it
                  snakes--;
                }
              int ladders;
                 cout<<"Enter number of ladders: ";
                 cin>>ladders;            //gets total number of ladders
                 cout<<"\n";
                 cout<<"Enter coordinate of the ladder";
                 ladders+=1;
                 while(ladders>0){
                  mysnake_ladders.ladder_coordinate();  //gets coordinates of each ladder and process it
                  ladders--;
                }
                
          
                Snake_ladder mysnake_ladder[players];  //creates object snake_ladder for as many players as possible
              int total_dice;
                 cout<<"Enter total number of dice: ";
                 cin>>total_dice;
                 
            while(total_dice>0){
              for(size_t i =0;i<players;i++){        //iterates through each player
                mysnake_ladder[i].draw(input);
                cout<<"\n\nFor player "<<i+1; 
                
        //        mysnake_ladder[i].display_test();
                mysnake_ladder[i].roll_dice(i);   //adds the the dice and checks for snake heads or ladder;if the addition of the dice falls on them do stuffs
                if(mysnake_ladder[i].winner(i)==true){
                  cout<<i+1<<" winner\n";
                  counter++;
                }
              }
              if(counter==players){
                break;
              }
              else if(counter==0 && total_dice==1){
                cout<<"no winner";
                break;
              }
              
              total_dice--;
            }
          }
          
            else{
              cout<<"players must be between 2 to 10"<<endl;
            }
          }
          else{
            cout<<"input must be an even number"<<endl;
          }
          return 0;
        }

        //  

      `); //1 = moves cursor to end
      
      editor.setOptions({
        fontSize: "10pt",
        showLineNumbers: false,
        showGutter: false,
        vScrollBarAlwaysVisible:true,
        enableBasicAutocompletion: false, enableLiveAutocompletion: false
      });

      editor.setShowPrintMargin(false);
      editor.setBehavioursEnabled(false);

      // editor1
      window.editor1 = ace.edit("editor1");
      editor1.setTheme("ace/theme/monokai");
      editor1.getSession().setMode("ace/mode/c_cpp");
      editor1.setValue(`
        #include <iostream>
        #include <vector>

        using namespace std;
        template<class U>
        class Keepboard{
          public:
            vector<vector<U>>arrs={};
        };

        template <class T>
        class Eightqueens
        {
          private:
            Keepboard<T> *keepboard= new Keepboard<T>[8];
            bool checkboard(const size_t cur_row, const size_t cur_col,vector<vector<T>>& arr){
              bool checker= false;
              vector<vector<T>>arrs={};
              arrs=arr;
              for(size_t k=0;k<8;k++){       //row=current row,col++
                if(arrs[cur_row][k] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              for(size_t m=0;m<8;m++){
                if(arrs[m][cur_col] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              
              for(size_t p=cur_row,q = cur_col;p!=8 && q!=8;p++,q++){ //diagonal from current position to right-down
            
                if(arrs[p][q] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              
              for(size_t x=cur_row,y= cur_col;x!=-1 && y!=-1;x--,y--){    //diagonal from current position to left-up
            
                if(arrs[x][y] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              
              for(size_t A=cur_row,B=cur_col;A!=-1&&B!=8;A--,B++){  //diagonal from current position to top right
              
                if(arrs[A][B] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              
              for(size_t A=cur_row,B=cur_col;B!=-1 &&A!=8;B--,A++){  //diagonal from current position to down left
              
                if(arrs[A][B] == 'Q'){
                  return true;
                }
                else{
                  checker=false;
                }
              }
              
              return checker;
            };  
            
          public:
            
            void maxnumqueens(vector<vector<T>>& arr);
            vector<vector<T>> putqueen(size_t col,vector<vector<T>>& arr);
            void printboard();
            ~Eightqueens(){
              delete[] keepboard;
            };
            
        };

        template<class T>
        void Eightqueens<T>::maxnumqueens(vector<vector<T>>& arr){
          for(size_t i=0;i<8;i++){
            keepboard[i].arrs=putqueen(i,arr);
          }
        }

        template<class T>
        vector<vector<T>> Eightqueens<T>::putqueen(size_t cols,vector<vector<T>>& arr){
          vector<vector<T>>arrs={};
          arrs=arr;
          for(size_t row=0;row<8;row++){
        //    cout<<"row "<<row<<endl;
            if(row>0){
              for(size_t col=0;col<8;col++){
                
                if(checkboard(row,col,arrs) == false){
          //        cout<<" Q ";
                  arrs[row][col] = 'Q';
                }
              }
            }
            else{
              for(size_t col=cols;col<8;col++){
                
                if(checkboard(row,col,arrs) == false){
          //        cout<<" Q ";
                  arrs[row][col] = 'Q';
                }
              }
            }
          }
          return arrs;
        }

        template<class T>
        void Eightqueens<T>::printboard(){
          for(size_t i=0;i<8;i++){
            for(size_t row=0;row<8;row++){
              for(size_t col=0;col<8;col++){
                cout<<keepboard[i].arrs[row][col]<<"";
              }
              cout<<endl;
            }
            cout<<"\n"<<endl;
          }
        }

        int main()
        {
          vector<vector<char> >arr={};
          
          for(size_t row=0;row<8;row++){
            arr.resize(8);
            for(size_t col=0;col<8;col++){
              arr[row].push_back('x');
            }
          }
          Eightqueens<char> eightqueens;
          eightqueens.maxnumqueens(arr);
          eightqueens.printboard();

          return 0;
        }

        `); //1 = moves cursor to end
      
      editor1.setOptions({
        fontSize: "11pt",
        showLineNumbers: false,
        showGutter: false,
        vScrollBarAlwaysVisible:true,
        enableBasicAutocompletion: false, enableLiveAutocompletion: false
      });

      editor1.setShowPrintMargin(false);
      editor1.setBehavioursEnabled(false);

      //editor2
      window.editor2 = ace.edit("editor2");
      editor2.setTheme("ace/theme/monokai");
      editor2.getSession().setMode("ace/mode/c_cpp");
      editor2.setValue(`
        #include <bits/stdc++.h>

        template<class U>
        class coordinate{
          public:
            int row=0;
            U data;
            int col=0;
            // int counter=0;
        };

        template <typename T, typename U>
        coordinate<U>* BFsearch(std::vector< std::string> &v, T row, T col, U charfind,T size1,T size2){
          coordinate<U> *result = new coordinate<U>;
          result->row = row;
          result->col = col;

          std::queue<coordinate<U>* > q;
          q.push(result);
          T temp1,temp2=0;
          while(!q.empty()){
            coordinate<U>* curr = q.front();
            temp1=curr->row;
            temp2=curr->col;
            // std::cout<<"temp1= "<<temp1<<", temp2= "<<temp2<<std::endl;
            if(v[curr->row][curr->col] == charfind){
              result->row = curr->row;
              result->col = curr->col;
              // result-> data = v[curr->row][curr->col];
              break; 
            }
            if(curr->col < size2-1){
              coordinate<U>* curr1= new coordinate<U>; 
              curr1->col = temp2 + 1;
              curr1->row=temp1;
              q.push(curr1);
            }

            if(curr->row < size1-1){
              coordinate<U>* curr2= new coordinate<U>; 
              curr2->row = temp1 + 1;
              curr2->col=temp2;
              q.push(curr2);
            }

            q.pop();
          }

          return result;
        }
        template <typename T, typename U>
        T newBFsearch(std::vector< std::string> &v, T row, T col, U charfind,T size1,T size2){
          coordinate<U> *result = new coordinate<U>;
          result->row = row;
          result->col = col;
           T counter =0;

          std::queue<coordinate<U>* > q;
          q.push(result);
          T temp1,temp2=0;
          while(!q.empty()){
            coordinate<U>* curr = q.front();
            temp1=curr->row;
            temp2=curr->col;
            // std::cout<<"temp1= "<<temp1<<", temp2= "<<temp2<<std::endl;
            if(v[curr->row][curr->col] == charfind){
              counter++;
              v[curr->row][curr->col]='#';
            }
            if(curr->col < size2-1){
              coordinate<U>* curr1= new coordinate<U>; 
              curr1->col = temp2 + 1;
              curr1->row=temp1;
              q.push(curr1);
            }

            if(curr->row < size1-1){
              coordinate<U>* curr2= new coordinate<U>; 
              curr2->row = temp1 + 1;
              curr2->col=temp2;
              q.push(curr2);
            }

            q.pop();
          }

          return counter;
        }
        int main(int argc, char const *argv[])
        {
          coordinate<char> *result1= new coordinate<char>;
          coordinate<char> *result2= new coordinate<char>;
          // coordinate<char> *result3= new coordinate<char>;
          int a,b=0;
          std::cout<<"Enter the dimension of the maze: "<<std::endl;
          std::cin>>a>>b;
          std::cout<<"fill in the maze: "<<std::endl;
          std::vector<std::string> v;
          for(size_t i=0;i<b;i++){
            std::string temp;
            std::cin>>temp;
            v.push_back(temp);
          }

          //search for A using Breadth first search- this will be the starting point
          result1 = BFsearch<int,char>(v,0,0,'A',v.size(),v.size());
          std::cout<<"A coordinate: row "<<result1->row<<", col: "<<result1->col<<", value: "<<result1->data<<"\n"<<std::endl;

          //search for S using Breadth first search- this will be the end point
          result2 = BFsearch<int,char>(v,0,0,'S',v.size(),v.size());

          std::cout<<"S coordinate: row "<<result2->row<<", col: "<<result2->col<<", value: "<<result2->data<<"\n"<<std::endl;

          //searching for shaded boxes(let O denote shaded boxes) between A and S
          
          int result3 = newBFsearch<int,char>(v,result1->row,result1->col,'O',result2->row+1,result2->col+1);

          std::cout<<"there are "<<result3<<" shaded boxes between A and S"<<std::endl;


          delete result1;
          delete result2;
          // delete result3;
          return 0;
        }
      `); //1 = moves cursor to end
      
      
      editor2.setOptions({
        fontSize: "12pt",
        showLineNumbers: false,
        showGutter: false,
        vScrollBarAlwaysVisible:true,
        enableBasicAutocompletion: false, enableLiveAutocompletion: false
      });

      editor2.setShowPrintMargin(false);
      editor2.setBehavioursEnabled(false);

      //editor3
      window.editor3 = ace.edit("editor3");
      editor3.setTheme("ace/theme/monokai");
      editor3.getSession().setMode("ace/mode/c_cpp");
      editor3.setValue(`
      #include <stdio.h>
      #include <stdlib.h>
      #include <math.h>
      #include <ctype.h>
      #include <string.h>
      #include <time.h>
      #include "leach.h"
      #include "const.h"
      #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      #pragma GCC diagnostic ignored "-Wunused-variable"
      #pragma GCC diagnostic ignored "-Wunused-value"
      #pragma GCC diagnostic ignored "-Wwrite-strings"
      #pragma GCC diagnostic ignored "-Wparentheses"

      int NUM_NODES = 10;    // number of nodes in the network  
                      // default is 50  
      int NETWORK_X = 200;   // X-size of network  
                      // default is 100  
      int NETWORK_Y = 200;   // Y-size of network  
                      // default is 100  
      double B_POWER = 1.5;   // initial battery power of sensors  
                      // default is 0.75  
      double MAX = 0.0;
      int count =0;
      int deadnode = 0;

      int BASE_STATION_X_DEFAULT = 100;

      int BASE_STATION_Y_DEFAULT = 250;

      int DEAD_NODE = 1;
      int MESSAGE_LENGTH = 500*8; //message length in bits

      int TRIALS = 10;


      struct sensor {
           short xLoc=0;        // X-location of sensor  
           short yLoc=0;        // Y-location of sensor   
         
          float bCurrent; // current battery power  
          float res_energy; //res_enery=initial power - average power consumed
          float bPower; // initial battery power  
          float pAverage; // average power consumed per   
                      // transmission period.  
           int round=0; // the last round that the sensor   
                      // served as a cluster head  
           int head=0;  // stores the index of the cluster head   
                      // for the sensor to transmit to, set to -1 if the   
                      // sensor is a cluster head  
           int cluster_members;// stores the total number of nodes in   
                      // the cluster, applicable only for   
                      // cluster head nodes  
           int head_count; // this contains the count of the   
                      // number of times a sensor has been   
                      // the head of a cluster, can be   
                      // removed for optimization later  
           int is_relay;
      };


      struct sensor BASE_STATION;
      struct sensor Relay_Node;

      int failed_transmit = 0, R_failed_transmit = 0;        // round where a failed transmission occurred  
      int bits_transmitted = 0, R_bits_transmitted = 0,new_bits_transmitted=0;       // count of bits transmitted  
      int power = FALSE, R_power = FALSE;
      int temp_cluster_members = 0, R_temp_cluster_members = 0;
      double average_energy = 0.0;
      double distance_X_old = 0.0, R_distance_X_old = 0.0;
      double distance_Y_old = 0.0, R_distance_Y_old = 0.0;
      double distance_old = 0.0, R_distance_old = 0.0;
      double distance_X_new = 0.0, R_distance_X_new = 0.0;
      double distance_Y_new = 0.0, R_distance_Y_new = 0.0;
      double distance_new = 0.0, R_distance_new = 0.0;


      // struct sensor * network_LEACH = (struct sensor *) malloc(NUM_NODES * sizeof(struct sensor));// wireless sensor network to run sim on 
      void delay(int number_of_seconds) 
      { 
          // Converting time into milli_seconds 
          int milli_seconds = 1000 * number_of_seconds; 
        
          // Stroing start time 
          clock_t start_time = clock(); 
        
          // looping till required time is not acheived 
          while (clock() < start_time + milli_seconds) 
              ; 
      } 
      double computeEnergyTransmit(int messageLength, int distance);
      // computes the energy needed to transmit the message  
      // inputs are the distance between the two nodes and  
      // the length of the message  
      double RelaycomputeEnergyTransmit(int messageLength, int rdistance);
      // computes the energy needed to transmit message from relay to base station  
      // inputs are the distance between the two nodes and  
      // the length of the message 
      bool relay_node(struct sensor *network_LEACH, FILE *fp);
      // selects the relay node from all the sensors
      //using their residual energy formula i.e the one
      //with the highest energy level
      double computeEnergyReceive(int messageLength);
      // computes the energy needed to receive a message   
      // input is the message length  
      double computeDataAggregate(int messageLength);

      void initializeNetwork(struct sensor *network);
      // initializes the network; randomly places nodes within   
      // the grid and sets battery power to default value  
      // void Transmit_Relay_Node();
       //Relay node will be the one transmitting to base station
      float averageEnergy(struct sensor *network, FILE *fp);
      // computes the average power of the sensors in the  
      // network as a percentage of starting power  
      // input is a sensor network  
      float avgEnergyRelayNode(struct sensor relay_node, FILE *fp);
      // computes the average power of the relay node

      //struct sensor * loadConfiguration(char * filename);
      // loads values for the network initialization    // including starting battery power, size of network,   
      // and number of nodes  
      bool cluster_head(struct sensor *network_LEACH, FILE *fp);
      //selects the clusterhead from all sensors
      //excluding the one used for relay node
      float averageEnergyClusterhead(struct sensor *network_LEACH, FILE *fp);
      //computes the average energy of current cluster head 
      //if it is less than threshold,go to cluster_head(network) 
      //to select new cluster head
      int runLeachSimulation(const struct sensor *network, FILE *fp);
      // takes an initialized sensor network and simulates   
      // the LEACH protocol on that network  
      // The network is unchanged so that the same network   
      // can be passed to other simulator functions  
      // The function returns the number of rounds for which the   
      // average power of the network remained above the threshold.   
      // int runStabilityTest(struct sensor *network, FILE *fp, int period); 

      int main()
      {

          struct sensor *network = (struct sensor*)malloc(NUM_NODES* sizeof(struct sensor));

          int i = 0;
          int j = 0;  
          int rounds_LEACH = 0; 
          int period=0; 
          int sensor_alive=0;
          int total_counter=0;
          // int rounds_DIRECT = 0;
          // int found = FALSE;
          //double average_comparison = 0.0;  
          // char filename[10];
          FILE *fp = fopen("result.txt","w+");
          if(!fp){
              printf("unable to open file");
              //fclose(fp);
          }

          BASE_STATION.xLoc = BASE_STATION_X_DEFAULT;
          BASE_STATION.yLoc = BASE_STATION_Y_DEFAULT;
            
          // initializeNetwork(network);
          // rounds_LEACH += runLeachSimulation(network,fp);
         // printf("current power is %i and base power is %i and x ans y locations are %i and %i\n",network[10].bCurrent,network[10].bPower,network[10].xLoc,network[10].yLoc);
          for(i = 0; i < TRIALS; i++){ 
              fprintf(fp, "--------------------\n");
              fprintf(fp, "Cluster %i\n",i+1);
              fprintf(fp, "--------------------\n");
              initializeNetwork(network); 
              rounds_LEACH += runLeachSimulation(network,fp);  
              }
        int value = (int)(((0.1 * rounds_LEACH)*(NUM_NODES*TRIALS))/rounds_LEACH);
          printf("\nTotal rounds is = %d \n\n", rounds_LEACH);  
          fprintf(fp,"\nTotal rounds is = %d \n\n", rounds_LEACH ); 

          //printf("Network lifetime = %i \n\n", (int)(0.8 * (NUM_NODES*TRIALS)));  
          //fprintf(fp,"Network lifetime = %i \n\n", (int)(0.8 * (NUM_NODES*TRIALS)));

          //printf("%i nodes dead after %d rounds \n\n", (int)(0.8 * (NUM_NODES*TRIALS)),rounds_LEACH);  
          //fprintf(fp," %i nodes dead after %d rounds \n\n", (int)(0.8 * (NUM_NODES*TRIALS)),rounds_LEACH);

          printf("packet sent = %i \n\n", (int)(new_bits_transmitted));
          fprintf(fp,"packet sent = %i \n\n", (int)(new_bits_transmitted));

          printf("packet loss = %i \n\n", (int)(0.03 * new_bits_transmitted));
          fprintf(fp,"packet loss = %i \n\n", (int)(0.03 * new_bits_transmitted)); 

         // printf("Stability Period\n\n");
          //fprintf(fp,"Stability Period\n\n"); 

          //printf("10 percent of the total number of nodes dead  %i\n\n",(int)((0.1 * rounds_LEACH)*(NUM_NODES*TRIALS))/rounds_LEACH);
          //fprintf(fp,"10 percent of the total number of nodes dead %i\n\n",(int)((0.1 * rounds_LEACH)*(NUM_NODES*TRIALS))/rounds_LEACH);

          //printf("%i nodes dead after %i rounds \n\n", (int)((0.1 * rounds_LEACH)*(NUM_NODES*TRIALS))/rounds_LEACH,(int)((value * rounds_LEACH)/ (NUM_NODES*TRIALS)));
          //fprintf(fp,"%i nodes dead after %i rounds \n\n", (int)((0.1 * rounds_LEACH)*(NUM_NODES*TRIALS))/rounds_LEACH,(int)((value * rounds_LEACH)/ (NUM_NODES*TRIALS))); 

      free(network);
      fclose(fp);
      return 0;

      }           // end main function  


      int runLeachSimulation(const struct sensor *network, FILE *fp){
      // Preconditions:   the network variable contains an initiailized    
      //          sensor network and all global variables have been   
      //          set using the loadConfiguration function. The simulation   
      //          runs a number of times equal to the TOTAL_ROUNDS variable.  
      // Postconditions:      the LEACH protocol simulation has been   
      //              run on the supplied network although the instance   
      //          of that variable within main memory has NOT been   
      //          modified. Output of statistics is currently to the   
      //          screen.  
             
      struct sensor *network_LEACH= (struct sensor*)malloc(NUM_NODES* sizeof(struct sensor));      // wireless sensor network to run sim on  


      int i = 0;              // indexing variables  
      int j = 0;
      int k = 0;
      int closest = 0;
      int rounds = 0;    
      int counter =0;
      int counting =0;
      int testing = 0;            // testing variable, TO BE REMOVED  
      int avgcount=0;
      // int recent_round = 1/CLUSTER_PERCENT;
      double threshold = 0.10;  //CLUSTER_PERCENT/1-CLUSTER_PERCENT*(round % 1/CLUSTER_PERCENT);
      double random_number;
      int cluster_head_count = 0;
      double percent_found = 0.0;

      bool relay_default=FALSE;
      bool cluster_head_default=FALSE;
      bool data_got = FALSE;
      bool R_data_got = FALSE;
      // copy the contents of the passed network to a temporary   
      // network so the same network can be passed to different   
      // protocol simulations  


      for(i = 0; i  < NUM_NODES; i++){
          network_LEACH[i].bPower = network[i].bPower;
          network_LEACH[i].xLoc = network[i].xLoc;
          network_LEACH[i].cluster_members = 0;
          network_LEACH[i].yLoc = network[i].yLoc;
          network_LEACH[i].bCurrent = network[i].bCurrent;
          network_LEACH[i].bPower = network[i].bPower;
          network_LEACH[i].pAverage = network[i].pAverage;
          network_LEACH[i].is_relay =network[i].is_relay;
          network_LEACH[i].head = network[i].head;
          network_LEACH[i].round = network[i].round;
          }

       while(averageEnergy(network_LEACH,fp) > threshold){
          if(avgEnergyRelayNode(Relay_Node,fp)> threshold){
              if(averageEnergyClusterhead(network_LEACH,fp) > threshold){
                  // printf("\ncount is %i\n",count );
                  //Transmission processes begins
                  // now the cluster heads must transmit the fact that they   
                  // are cluster heads to the network, this will be a constant   
                  // transmit energy, during this period the other nodes must   
                  // keep their receivers on - which has an energy cost, again   
                  // this is constant  
                  // data_got = FALSE;
                  // DATA TRANSMISSION from sensors to current clusterhead
                      // non cluster heads send their data to the cluster heads 
                      // cluster heads transmit to relay node
                  for(i = 0; i < NUM_NODES; i++){
                      if(network_LEACH[i].is_relay != 1 && i!=count && network_LEACH[i].head != -1){      //this removes the sensor selected for relay node
                          if(network_LEACH[i].head != DEAD_NODE ){
                              distance_X_new = network_LEACH[i].xLoc - network_LEACH[count].xLoc;
                              distance_Y_new = network_LEACH[i].yLoc - network_LEACH[count].yLoc;
                              distance_new = sqrt(pow(distance_X_new, 2) + pow(distance_Y_new, 2));
                              network_LEACH[i].bCurrent -= computeEnergyTransmit(MESSAGE_LENGTH,distance_new);
                              network_LEACH[count].bCurrent -= computeEnergyReceive(MESSAGE_LENGTH);
                               //rounds++;
                                  if((network_LEACH[i].bCurrent / network_LEACH[i].bPower) > .10){
                                      bits_transmitted += (MESSAGE_LENGTH * (network_LEACH[i].cluster_members+1));
                                      data_got= TRUE;
                                      fprintf(fp, "\nsensor %i transmitted data %i to clusterhead %i \n",i,MESSAGE_LENGTH,count);
                                      printf("\nsensor %i transmitted data %i to clusterhead %i \n",i,MESSAGE_LENGTH,count);
                                  }
                                  else{
                                      failed_transmit++;
                                      network_LEACH[i].head = DEAD_NODE;
                                     deadnode++;
                                      temp_cluster_members = network_LEACH[i].cluster_members + 1;
                                      // network_LEACH[i].bCurrent += computeEnergyTransmit(MESSAGE_LENGTH * (network_LEACH[i].cluster_members+1),distance_new);
                                      data_got = FALSE;

                                  }
                              }
                              else{
                                  counter++;
                              }
                             
                          }
                      }
                  //     if(deadnode > (NUM_NODES-1)){
                    // rounds++;
                  //         break;
                  //     }
          // delay(5);
                      // else{
              //this transmit from current clusterhead to current relay node
                          if(data_got == TRUE) {
                               if(network_LEACH[count].is_relay != 1){      //this removes the sensor selected for relay node
                                  if(network_LEACH[count].head == -1){
                                      distance_X_new = network_LEACH[count].xLoc - Relay_Node.xLoc;
                                      distance_Y_new = network_LEACH[count].yLoc - Relay_Node.yLoc;
                                      distance_new = sqrt(pow(distance_X_new, 2) + pow(distance_Y_new, 2));
                                       //rounds++;
                                          if((network_LEACH[count].bCurrent / network_LEACH[count].bPower) > .10){
                                              R_data_got = TRUE;
                                              network_LEACH[count].bCurrent -= computeDataAggregate(bits_transmitted);
                                              network_LEACH[count].bCurrent -= computeEnergyTransmit(bits_transmitted,distance_new);
                                              Relay_Node.bCurrent -= computeEnergyReceive(bits_transmitted);
                                          }
                                          else{
                                              failed_transmit++;
                                              network_LEACH[count].head = DEAD_NODE;
                                              temp_cluster_members = network_LEACH[count].cluster_members + 1;
                                              printf("\nreselecting clusterhead....\n");
                                              fprintf(fp,"\nreselecting clusterhead...\n");
                                              if(cluster_head(network_LEACH,fp)==TRUE){
                                                  // network_LEACH[count].bCurrent -= computeDataAggregate(bits_transmitted);
                                                  network_LEACH[count].bCurrent -= computeEnergyTransmit(bits_transmitted,distance_new);
                                                  Relay_Node.bCurrent -= computeEnergyReceive(bits_transmitted);
                                              }
                                              else R_data_got=FALSE;
                
                                              // continue;
                                      }
                                          fprintf(fp, "\nCluster Head Aggregates data %i to Relay node\n",bits_transmitted);
                                          printf("\nCluster Head Aggregates data %i to Relay node\n",bits_transmitted);
                                          fprintf(fp, "\nCluster Head transmits data %i to Relay node\n",bits_transmitted);
                                          printf("\nCluster Head transmits data %i to Relay node\n",bits_transmitted);
                                     }
                                  }
                     // delay(5);
                      //transmit from relay node to base station if it has anything to transmit
                                  if(R_data_got == TRUE){
                                      if(Relay_Node.head ==-1){
                                          R_distance_X_new = Relay_Node.xLoc - BASE_STATION.xLoc;
                                          R_distance_Y_new = Relay_Node.yLoc - BASE_STATION.yLoc;
                                          R_distance_new = sqrt(pow(R_distance_X_new, 2) + pow(R_distance_Y_new, 2));
              
                                          if(Relay_Node.bCurrent/Relay_Node.bPower > 0.1){
                                              R_bits_transmitted = bits_transmitted;
                                              Relay_Node.bCurrent -= RelaycomputeEnergyTransmit(R_bits_transmitted,R_distance_new);

                                          }
                                          else{
                                              R_failed_transmit++;
                                              Relay_Node.head = DEAD_NODE;
                                              R_temp_cluster_members = Relay_Node.cluster_members + 1;
                                              // Relay_Node.bCurrent += RelaycomputeEnergyTransmit(bits_transmitted,R_distance_new);
                                               R_bits_transmitted = bits_transmitted;
                                               printf("\nreselecting relaynode...\n");
                                               fprintf(fp,"\nreselecting relaynode...\n");
                                               if(relay_node(network_LEACH,fp) == TRUE)
                                                  Relay_Node.bCurrent -= RelaycomputeEnergyTransmit(R_bits_transmitted,R_distance_new);
                                          }
                                         
                                          fprintf(fp, "\nRelay node %i transmitted data %i to BS\n",Relay_Node.round,R_bits_transmitted);
                                          printf("\nRelay node %i transmitted data %i to BS\n",Relay_Node.round,R_bits_transmitted);
                                      }
                                  }
                                  else{
                                      // fprintf(fp, "\nEnergy of sensors in this cluster are deplected..\n");
                                      return rounds;
                                  }
              // delay(5);
                            }
                            else{
                              // fprintf(fp, "\nEnergy of sensors in this cluster are deplected..\n");
                              return rounds;
                          }
                     rounds++;
                        // }
                           new_bits_transmitted +=bits_transmitted;
                            bits_transmitted=0;
                  }
              else{
                  printf("\ncluster head selection...\n");
                  fprintf(fp,"\ncluster head selection...\n");
                  // network_LEACH[count].head = DEAD_NODE;
                  cluster_head_default = cluster_head(network_LEACH,fp);
                  if(cluster_head_default == FALSE){
                      // avgcount++;
                     break;
                  }
                  // else if(averageEnergy(network_LEACH,fp) < 0.1){
                  //     break;
                  // }
              }
          }
          else{
              printf("\nrelay node selection...\n");
              fprintf(fp,"\nrelay node selection...\n");
              relay_default = relay_node(network_LEACH,fp);
              if(relay_default == FALSE){
                     break;
              }
          }
      }
      free(network_LEACH);
      //fclose(fp);

      count=0;
      return rounds;
      }       // end runLeachSimulation function  

      double computeEnergyTransmit(int messageLength,int distance){
      // Preconditions:   distance contains the distance between the transmitting   
      //                  node and the receiving node. messageLength contains   
      //                  the length of the message in bits.  
      // Postconditions:  the total energy consumed by the transmission is   
      //                  returned  

          float E_elec = 50 * pow(10,-9);
          float Efs= 1 * pow(10,-11);
          float dis = 1 * pow(distance,2);
              //float epsilon_amp = 100 * pow(10,-12);
              double EnergyUse = 0.00;

              EnergyUse = (messageLength * E_elec) + (messageLength * Efs * dis);

          return EnergyUse;

      }           // end computeEnergyTransmit function

      double RelaycomputeEnergyTransmit(int messageLength,int rdistance){
      // Preconditions:   distance contains the distance between the transmitting   
      //                  node and the receiving node. messageLength contains   
      //                  the length of the message in bits.  
      // Postconditions:  the total energy consumed by the transmission is   
      //                  returned  

          float E_elec = 50 * pow(10,-9);
          float Eamp=  1.3 * pow(10,-15);
          float rdis = 1 * pow(rdistance,4);
              //float epsilon_amp = 100 * pow(10,-12);
              double EnergyUse = 0.00;

              EnergyUse = (messageLength * E_elec) + (messageLength * Eamp * rdis);
              // printf("Energy consumed by relay: %f\n",EnergyUse);

          return EnergyUse;

      }           // end computeEnergyTransmit function 

      double computeEnergyReceive(int messageLength) {
      // Preconditions:   messageLength contains the length of the  
      //                  message in bits to be received by the station.  
      // Postconditions:  the total energy consumed by the reception   
      //              of the transmission is returned.      
          return messageLength * (50 * pow(10,-9));
      }           // end computeEnergyReceive function  

      double computeDataAggregate(int messageLength) {  
      // Postconditions:  the total energy consumed by the when cluster head
      //                    perform data aggregation is returned.      
          return messageLength * (5 * pow(10,-9));
      }  

      void initializeNetwork(struct sensor *network) {
      // Preconditions:   network is an unitialized sensor network.  
      // Postconditions:  network is an initialized sensor network   
      //                  whose values are loaded from global varibles   
      //          which are set using the loadConfiguration   
      //          function or the defaults are used  
          int i = 0;
          srand((unsigned int) time(0));

          for(i = 0; i < NUM_NODES; i++) {
              network[i].xLoc = rand() % NETWORK_X;
              network[i].yLoc = rand() % NETWORK_Y;
              network[i].bCurrent = 1.1;
              network[i].bPower = B_POWER;
              network[i].pAverage =   network[i].bCurrent /network[i].bPower;
              network[i].round = 0;
              network[i].head = 0;
              network[i].is_relay=0;
              // printf("\n%d   %d   %f   %f  %f  %i\n",network[i].xLoc,network[i].yLoc,network[i].bCurrent,network[i].bPower,network[i].pAverage,network[i].is_relay);
              // network[i].res_energy = network[i].bPower- network[i].pAverage;
              }
              // printf("\ncode got here\n");
              Relay_Node.xLoc=0.0;
              Relay_Node.yLoc=0.0;
              Relay_Node.bCurrent=0.01;
              Relay_Node.bPower=B_POWER;
              Relay_Node.pAverage= Relay_Node.bCurrent/Relay_Node.bPower;
              Relay_Node.round=0;
              Relay_Node.is_relay=0;
              // Relay_Node.res_energy = B_POWER;
              Relay_Node.head = 0;
              count=0;
              deadnode =0;

              // printf("\n%d   %d   %f   %f  %f  %i\n",Relay_Node.xLoc,Relay_Node.yLoc,Relay_Node.bCurrent,Relay_Node.bPower,Relay_Node.pAverage,Relay_Node.is_relay);

      }           // end initializeNetwork function 

      //select relaynode from the clusters and return true
      bool relay_node (struct sensor *network_LEACH, FILE *fp){
          deadnode++;
          if(deadnode> NUM_NODES-1){
              return FALSE;
          }
          // printf("network_LEACH[i].is_relay = i && network_LEACH[i].head = %i",network_LEACH[i].is_relay  && network_LEACH[i].head == 0 );
          // threshold = CLUSTER_PERCENT/1-CLUSTER_PERCENT*(round % 1/CLUSTER_PERCENT);
           for(int i = 0; i < NUM_NODES; i++){
              if(network_LEACH[i].is_relay == 0 && network_LEACH[i].head == 0){
                  // if(network_LEACH[i].head != -1){
                      network_LEACH[i].pAverage =  network_LEACH[i].bCurrent /network_LEACH[i].bPower;
                      Relay_Node.pAverage = network_LEACH[i].pAverage;
                      // count = i;
                      Relay_Node.head = -1;
                      Relay_Node.xLoc = network_LEACH[i].xLoc;
                      Relay_Node.yLoc = network_LEACH[i].yLoc;
                      Relay_Node.bCurrent = network_LEACH[i].bCurrent;
                      Relay_Node.bPower = network_LEACH[i].bPower ;
                      network_LEACH[i].is_relay = 1;
                      network_LEACH[i].head = DEAD_NODE;
                      Relay_Node.round = i;
                      printf("\n relay_node %i has been selected\n",i);
                      fprintf(fp,"\n relay_node %i has been selected\n",i);
                      return TRUE;
                  // }
              }
          }
          // printf("\n no relay_node selected\n");
           // fprintf(fp,"\n no relay_node selected\n");

           //fclose(fp);
          return FALSE;
      }


      bool cluster_head(struct sensor *network_LEACH, FILE *fp){
          deadnode++;
          if(deadnode> NUM_NODES-1){
              return FALSE;
          }
          // count =1;
          for(int i = 0; i < NUM_NODES; i++){
              if(network_LEACH[i].is_relay != 1){
                  if(network_LEACH[i].head != -1){
                      if(network_LEACH[i].head != DEAD_NODE ){
                          network_LEACH[i].pAverage =  network_LEACH[i].bCurrent /network_LEACH[i].bPower;
                          // count = i;
                          network_LEACH[i].head = -1;
                          network_LEACH[i].round = 1;
                          network_LEACH[i].head_count++;
                          // network_LEACH[i].head = DEAD_NODE;
                                      // network_LEACH[i].round = i;
                           // cluster_head_count++;
                              count = i;
                          printf("\n cluster head %i has been selected\n",i);
                          fprintf(fp,"\n cluster head %i has been selected\n",i);
                          return TRUE;
                      }
                  }
              }
          }
          printf("\n no cluster head selected\n");
           fprintf(fp,"\n no cluster head selected\n");

          //fclose(fp);
          return FALSE;
      }

      float avgEnergyRelayNode(struct sensor relay_node, FILE *fp) { 
      // Postconditions:  the average percentage of power in the   
      //                  battery of the relay node.
          float average = 0.0;
          float starting_power = 0.10;
          float current_power = 0.10;

              starting_power = relay_node.bPower;
              current_power = relay_node.bCurrent;
              average = current_power/starting_power;
              // relay_node.pAverage = current_power/starting_power;
        if(average <=0.006667){
                  printf("\naverage relay energy is %f\n",average);
                  fprintf(fp,"\naverage relay energy is %f\n",average);
        }
        else{
           printf("\nrelay node residual energy is %f\n",average);
                 fprintf(fp,"\nrelay node residual energy is %f\n",average);
        }

          return current_power/starting_power;

      }  

      float averageEnergy (struct sensor *network, FILE *fp) {
      // Preconditions:   network is an initialized sensor network  
      // Postconditions:  the average percentage of power in the   d
      //                  batteries across the network is returned.  
      //                  i.e. 0.90 means that the average battery   
      //                  in the network is at 90% of its original   
      //                  power  
          float average = 0.0;
          float starting_power = 0.10;
          float current_power = 0.10;
          int i = 0;

          for(i = 0; i < NUM_NODES; i++) {
              starting_power += network[i].bPower;
              current_power += network[i].bCurrent;
          }
          average = current_power/starting_power;
          // //fclose(fp);
          return average;

      }           // end averageEnergy function  

      float averageEnergyClusterhead(struct sensor *network_LEACH, FILE *fp) {
      // Preconditions:   network is an initialized sensor network  
      // Postconditions:  the average percentage of power in the   
      //                  batteries across the network is returned.  
      //                  i.e. 0.90 means that the average battery   
      //                  in the network is at 90% of its original   
      //                  power  
          float average = 0.00f;
          float starting_power = 0.10;
          float current_power = 0.10;
          int i = 0;
          for(i =1; i<NUM_NODES;i++){
              if(network_LEACH[i].is_relay != 1){
               if(network_LEACH[i].head == -1 && i==count){
                       starting_power = network_LEACH[i].bPower;
                       current_power = network_LEACH[i].bCurrent;
                       average = current_power/starting_power;
                       // printf("clusterhead averageEnergy is %f",average);
                       // fprintf(fp,"\naverageEnergyClusterhead %f\n",average );
                       // network_LEACH[count].pAverage=average;
                      }
                  }
              }
        if(average<=0.00){
                  printf("\naverage Clusterhead Energy is %f\n",average);
                  fprintf(fp,"\naverage Clusterhead Energy is %f\n",average);
        }
        else{
            printf("\nClusterhead node residual energy is %f\n",average);
                  fprintf(fp,"\nClusterhead node residual energy is %f\n",average);
        }
          // //fclose(fp);
          return average;
        }
`); //1 = moves cursor to end

      editor3.getSession().on('change', function() {
        update();
      });

      editor3.focus();
      
      
      editor3.setOptions({
        fontSize: "9pt",
        showLineNumbers: false,
        showGutter: false,
        vScrollBarAlwaysVisible:true,
        enableBasicAutocompletion: false, enableLiveAutocompletion: false
      });

      editor3.setShowPrintMargin(false);
      editor3.setBehavioursEnabled(false);
    }
    function ready(){
      setupEditor();
  }
  </script>
  <!-- JavaScript Libraries -->
  <script src="lib/jquery/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/mode-c_cpp.js"></script>
  <script src="lib/jquery/jquery-migrate.min.js"></script>
  <script src="lib/popper/popper.min.js"></script>
  <script src="lib/bootstrap/js/bootstrap.min.js"></script>
  <script src="lib/easing/easing.min.js"></script>
  <script src="lib/counterup/jquery.waypoints.min.js"></script>
  <script src="lib/counterup/jquery.counterup.js"></script>
  <script src="lib/owlcarousel/owl.carousel.min.js"></script>
  <script src="lib/lightbox/js/lightbox.min.js"></script>
  <script src="lib/typed/typed.min.js"></script>
  <!-- Contact Form JavaScript File -->
  <script src="contactform/contactform.js"></script>

  <!-- Template Main Javascript File -->
  <script src="js/main.js"></script>

</body>
</html>
